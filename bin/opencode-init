#!/usr/bin/env node
import { execSync } from 'node:child_process';
import { existsSync } from 'node:fs';
import inquirer from 'inquirer';
import ora from 'ora';
import chalk from 'chalk';
import detectInstaller from 'detect-installer';

const CONFIG_DIR = process.env.HOME + '/.config/opencode';
const BIN_DIR = CONFIG_DIR + '/bin';
const SHELL_CONFIG = process.env.HOME + '/.zshrc';
const OPENCODE_BIN = `${CONFIG_DIR}/bin`;

const TOOLS = {
  cass_memory: {
    name: 'cass_memory (cm)',
    install: 'curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/cass_memory_system/main/install.sh | bash -s -- --easy-mode --verify',
    check: 'cm --version',
    required: true,
  },
  biome: {
    name: 'Biome (linting + formatting)',
    install: 'npm install -g @biomejs/biome',
    check: 'biome --version',
    required: true,
  },
  prettier: {
    name: 'Prettier (code formatter)',
    install: 'npm install -g prettier',
    check: 'prettier --version',
    required: true,
  },
  beads_cli: {
    name: 'Beads CLI (bd) - Task tracking',
    install: 'go install github.com/steveyegge/beads/cmd/bd@latest',
    check: 'bd --version',
    required: true,
    depends_on: ['go'],
  },
  beads_viewer: {
    name: 'Beads Viewer (bv) - Task browser',
    install: 'curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/beads_viewer/main/install.sh?$(date +%s)" | bash',
    check: 'bv --version',
    required: true,
  },
  osgrep: {
    name: 'Osgrep - Semantic code search',
    install: 'npm install -g @steveyegge/osgrep',
    check: 'osgrep --version',
    required: false,
  },
  ubs: {
    name: 'Ultimate Bug Scanner (UBS) - Static analysis',
    install: 'curl -fsSL "https://raw.githubusercontent.com/Dicklesworthstone/ultimate_bug_scanner/master/install.sh?$(date +%s)" | bash',
    check: 'ubs --version',
    required: false,
  },
  go: {
    name: 'Go (for Beads CLI)',
    install: 'go installation requires manual steps',
    check: 'go version',
    required: false,
  },
};

function commandExists(cmd) {
  try {
    execSync(`command -v ${cmd} 2>/dev/null`, { stdio: 'ignore' });
    return true;
  } catch {
    return false;
  }
}

function checkTool(toolKey) {
  const tool = TOOLS[toolKey];
  try {
    const output = execSync(tool.check, { encoding: 'utf8', stdio: 'pipe' });
    const version = output.trim().split('\n')[0];
    return { installed: true, version };
  } catch {
    return { installed: false, version: null };
  }
}

function isToolRequired(toolKey, selectedTools) {
  const tool = TOOLS[toolKey];
  if (!tool.depends_on) return tool.required;
  return selectedTools.includes(toolKey);
}

async function runCommand(cmd, description) {
  const spinner = ora(description).start();
  try {
    execSync(cmd, { stdio: 'pipe' });
    spinner.succeed();
    return true;
  } catch (error) {
    spinner.fail();
    console.error(chalk.red(`Error: ${error.message}`));
    return false;
  }
}

async function installGo() {
  const { useHomebrew } = await inquirer.prompt([
    {
      type: 'confirm',
      name: 'useHomebrew',
      message: 'Install Go using Homebrew?',
      default: true,
    },
  ]);

  if (useHomebrew && commandExists('brew')) {
    return await runCommand('brew install go', 'Installing Go via Homebrew');
  }

  console.log(chalk.yellow('Please install Go manually from: https://golang.org/dl/'));
  return false;
}

async function main() {
  console.log(chalk.cyan.bold('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
  console.log(chalk.cyan.bold('â•‘   OpenCode - Interactive System Setup                      â•‘'));
  console.log(chalk.cyan.bold('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));

  const { runSetup } = await inquirer.prompt([
    {
      type: 'confirm',
      name: 'runSetup',
      message: 'Would you like to set up opencode tools?',
      default: true,
    },
  ]);

  if (!runSetup) {
    console.log(chalk.yellow('Setup cancelled. Run again anytime: opencode-init-interactive'));
    process.exit(0);
  }

  console.log(chalk.blue('\nðŸ“Š Checking current tool status...\n'));

  const toolStatus = {};
  for (const [key, tool] of Object.entries(TOOLS)) {
    const status = checkTool(key);
    toolStatus[key] = status;
    
    const statusIcon = status.installed ? chalk.green('âœ“') : chalk.yellow('â—‹');
    const versionInfo = status.installed ? chalk.gray(` (${status.version.split(' ')[0]})`) : '';
    const requiredTag = tool.required ? chalk.red(' (required)') : chalk.gray(' (optional)');
    console.log(`${statusIcon} ${tool.name}${versionInfo}${requiredTag}`);
  }

  const { toolsToInstall } = await inquirer.prompt([
    {
      type: 'checkbox',
      name: 'toolsToInstall',
      message: 'Select tools to install:',
      choices: Object.entries(TOOLS).map(([key, tool]) => ({
        name: `${tool.name} ${toolStatus[key].installed ? chalk.gray('(already installed)') : ''}`,
        value: key,
        disabled: toolStatus[key].installed,
        checked: tool.required && !toolStatus[key].installed,
      })),
    },
  ]);

  if (toolsToInstall.length === 0) {
    console.log(chalk.green('\nâœ“ All tools are already installed!'));
    await configurePath();
    process.exit(0);
  }

  console.log(chalk.blue(`\nðŸ”§ Installing ${toolsToInstall.length} tool(s)...\n`));

  for (const toolKey of toolsToInstall) {
    const tool = TOOLS[toolKey];
    
    if (toolKey === 'go') {
      const success = await installGo();
      if (!success) {
        console.log(chalk.red(`Skipping tools that depend on Go`));
        continue;
      }
      continue;
    }

    if (tool.depends_on && tool.depends_on.includes('go') && !commandExists('go')) {
      console.log(chalk.yellow(`Skipping ${tool.name}: Go is required`));
      continue;
    }

    const success = await runCommand(tool.install, `Installing ${tool.name}`);
    if (!success) {
      console.log(chalk.red(`Failed to install ${tool.name}`));
    }
  }

  await configurePath();

  console.log(chalk.cyan.bold('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
  console.log(chalk.cyan.bold('â•‘   Setup Complete!                                           â•‘'));
  console.log(chalk.cyan.bold('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
  console.log(chalk.green('\nâœ“ All tools installed and configured\n'));
  console.log(chalk.yellow('Next steps:'));
  console.log('  1. Source your shell configuration:');
  console.log(chalk.cyan(`     source ${SHELL_CONFIG}`));
  console.log('  2. Or start a new terminal');
  console.log('  3. Initialize your project workspace:');
  console.log(chalk.cyan(`     ${BIN_DIR}/workspace-init`));
  console.log();
}

async function configurePath() {
  const currentPath = process.env.PATH;
  if (currentPath.includes(OPENCODE_BIN)) {
    console.log(chalk.green('âœ“ PATH already configured'));
    return;
  }

  const { configurePath } = await inquirer.prompt([
    {
      type: 'confirm',
      name: 'configurePath',
      message: `Add ${OPENCODE_BIN} to PATH?`,
      default: true,
    },
  ]);

  if (configurePath) {
    const spinner = ora('Configuring PATH').start();
    try {
      const pathEntry = `export PATH="${OPENCODE_BIN}:$PATH"`;
      execSync(`echo '${pathEntry}' >> ${SHELL_CONFIG}`, { stdio: 'pipe' });
      spinner.succeed('PATH configured');
    } catch (error) {
      spinner.fail();
      console.error(chalk.red(`Error configuring PATH: ${error.message}`));
    }
  }
}

main().catch((error) => {
  console.error(chalk.red(`Fatal error: ${error.message}`));
  process.exit(1);
});
